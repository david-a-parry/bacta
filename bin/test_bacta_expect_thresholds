#!/usr/bin/env python
import argparse
import sys
import os
import re
import bisect
import pysam
import logging
import multiprocessing as mp
from itertools import repeat
import numpy as np
import matplotlib
# Force matplotlib to not use any Xwindows backend.
matplotlib.use('Agg')
import matplotlib.pyplot as plt
from matplotlib.backends.backend_pdf import PdfPages
from sklearn.metrics import roc_curve, auc
from collections import defaultdict
from bacta.cigar_scorer import CigarScorer
from bacta.find_contaminants import length_from_fai
from bacta.alignment_file_utils import get_bamfile
from bacta.benchmark_utils import contigs_from_fasta, write_table
from bacta.benchmark_utils import report_precision_recall
from bedfinder import BedFinder

def test_expect(bam, output, ref, expect_values, prog_interval, 
                decoy_contigs=[], avoid_regions=None, debug=False, quiet=False, 
                logfile=None):
    ''' 
        Read contaminat BAM generated by BACTA from simulated reference and 
        contaminant reads (generated by DWGSIM) and test 
        sensitivity/specificity at differing 'expect' values. Produces a table 
        and plots.
    '''
    expect_values.sort()
    if min(expect_values) < 0.0:
        raise RuntimeError("Error in arguments: --expect_values values can " +
                           "not be below 0.0")
    table_fn = output + ".tsv"
    table_out = open(table_fn, "wt")
    logger = get_logger(debug=debug, quiet=quiet, logfile=logfile)
    decoys = set(decoy_contigs)
    counts = read_bam(bam, ref, logger, expect_values, decoys, avoid_regions,
                      prog_interval)
    df = write_table(counts, table_out)
    report_precision_recall(df, logger)
    write_plots(df, output, logger)

def write_plots(df, prefix, logger):
    plt.style.use('seaborn-whitegrid')
    output = prefix + "_plots.pdf"
    logger.info("Writing plots to {}...".format(output))
    total_ref = df['REF'].sum()
    total_contam = df['CONTAM'].sum()
    roc_auc = auc(df['1-Specificity'], df['Sensitivity'])
    with PdfPages(output) as pdf:
        logger.info("Generating classification plots...")
        plt.figure(figsize=(11.7, 8.27), dpi=300)
        lw = 2
        plt.title("Fraction per Classification")
        plt.plot(df.Threshold, df.FP/total_ref)
        plt.plot(df.Threshold, df.TP/total_contam)
        plt.yscale('log')
        plt.xscale('log')
        plt.xlabel('Expect Difference Cutoff')
        plt.ylabel('Fraction')
        plt.legend(['FP', 'TP'], loc="right")
        pdf.savefig()
        
        plt.figure(figsize=(11.7, 8.27), dpi=300)
        plt.title("Number of Reads per Classification")
        plt.plot(df.Threshold, df.FP)
        plt.plot(df.Threshold, df.TP)
        plt.yscale('log')
        plt.xscale('log')
        plt.xlabel('Expect Difference Cutoff')
        plt.ylabel('Reads')
        plt.legend(['FP', 'TP'], loc="right")
        pdf.savefig()

        #ROC curve
        logger.info("Writing ROC curve...")
        n = 0
        plt.figure(figsize=(11.7, 8.27), dpi=300)
        plt.plot(df['1-Specificity'], df['Sensitivity'], lw=lw, 
                     label='ROC curve (area = {:g})'.format(roc_auc))
        plt.plot([0, 1], [0, 1], color='black', lw=lw, linestyle=':')
        plt.xlim([0.0, 1.0])
        plt.ylim([0.0, 1.05])
        plt.xlabel('False Positive Rate')
        plt.ylabel('True Positive Rate')
        plt.title('Receiver operating characteristic for expect thresholds')
        plt.legend(loc="lower right")
        pdf.savefig()
        logger.info("Finished generating plots")


def read_overlapped(bedfinder, cigar_scorer, length, cigar, coord):
    ctups = cigar_scorer.cigarstring_to_tuples(cigar)
    try:
        chrom, pos = coord.rsplit(':', 1)
        pos = int(pos)
    except ValueError:
        return None
    s_off, e_off = cigar_scorer.get_clipped_offset(ctups)
    start = pos - s_off
    end = cigar_scorer.get_aligned_length(ctups) + pos + e_off
    return bedfinder.fetch(chrom, start, end)

def read_bam(bam, ref, logger, expect_values, decoys, avoid_bed=None,
             prog_interval=100000):
    rid_to_coord_re = re.compile(r'''^(\S+)_(\d+)_(\d+)(_\d+){5}:''')
    cigar_scorer = CigarScorer()
    bamfile = get_bamfile(bam) 
    contam_ref_length = sum(bamfile.lengths)
    ref_length = length_from_fai(ref)
    ref_contigs = contigs_from_fasta(ref)
    contam_contigs = set(bamfile.references)
    if ref_contigs.intersection(contam_contigs):
        sys.exit("ERROR: The following contigs are present in both " + 
                 "--ref and contaminant genomes:\n" + 
                 str.join("\n", 
                          sorted(ref_contigs.intersection(contam_contigs))))
    bfinder = None
    if avoid_bed:
        logger.info("Reading BED of regions to ignore ({})".format(avoid_bed))
        bfinder = BedFinder(avoid_bed)
        logger.info("Finished parsing BED.")
    warned_contigs = set()
    pairs = dict()
    counts = dict()
    for e in expect_values:
        counts[e] = {'CONTAM': 0, 'REF': 0}
    n = 0
    ref_total = 0
    contam_total = 0
    logger.info("Reading input BAM")
    for read in bamfile.fetch(until_eof=True):
        if read.is_secondary or read.is_supplementary:
            continue
        match = rid_to_coord_re.match(read.query_name)
        if match:
            chrom = match.group(1)
            start = match.group(2)
            end = match.group(3)
        else:
            logger.warn("Could not parse originating contig " +
                         "for read '{}'. ".format(read.query_name) + 
                         "Is this from a DWGSIM simulated read?")
            continue
        if chrom in contam_contigs:
            is_contam = True
            rtype = 'CONTAM'
            contam_total += 1
        elif chrom in ref_contigs:
            if chrom in decoys: 
                continue
            is_contam = False
            rtype = 'REF'
            ref_total += 1
        else:
            if chrom not in warned_contigs:
                logger.warn("Could not determine origin of " +
                            "contig for '{}'. ".format(chrom) + 
                            "Is this contig in either of your reference " + 
                            "files?")
                warned_contigs.add(chrom)
            continue
        n += 1
        if not n % prog_interval:
            logger.info("Reading input: {:,} primary alignments ".format(n) + 
                        "read, {:,} reference, {:,} contaminants."
                        .format(contam_total, ref_total))
        read_length = read.infer_query_length() or read.query_length
        ref_cigar = read.get_tag('ZC')
        if bfinder:
            if is_contam:
                old_pos = read.get_tag('ZP')
                if read_overlapped(bfinder, cigar_scorer, read_length, 
                                   ref_cigar, old_pos):
                    continue
            else: #use originating simulated coords if read is from reference
                if bfinder.fetch(chrom, start, end):
                    continue
        if read.cigartuples is None:
            contam_score = 0
        else:
            contam_score = cigar_scorer.score_cigartuples(read.cigartuples)
        ref_score    = cigar_scorer.score_cigarstring(ref_cigar)
        contam_e = read_length * contam_ref_length * 2**-contam_score
        ref_e    = read_length * ref_length        * 2**-ref_score
        if read.is_paired:
            if read.query_name in pairs:
                p_ref_e, p_contam_e = pairs[read.query_name] 
                del pairs[read.query_name] 
                diff = (ref_e * p_ref_e)/(contam_e * p_contam_e)
            else:
                pairs[read.query_name] = (ref_e, contam_e)
                continue
        else:
            diff = ref_e/contam_e
        e = bisect.bisect_left(expect_values, diff)
        e = e if e < len(expect_values) else e - 1
        counts[expect_values[e]][rtype] += 1
    bamfile.close()
    logger.info("Finished parsing {:,} primary alignments (".format(n) + 
                        "{:,} reference, {:,} contaminants)."
                        .format(contam_total, ref_total))
    return counts

def get_logger(debug=False, quiet=False, logfile=None):
    logger = logging.getLogger("EXPECT TEST")
    if debug:
        logger.setLevel(logging.DEBUG)
    elif quiet:
        logger.setLevel(logging.WARNING)
    else:
        logger.setLevel(logging.INFO)
    formatter = logging.Formatter(
                    '[%(asctime)s] %(name)s - %(levelname)s - %(message)s')
    ch = logging.StreamHandler()
    ch.setLevel(logger.level)
    ch.setFormatter(formatter)
    logger.addHandler(ch)
    if logfile is not None:
        fh = logging.FileHandler(logfile)
        fh.setLevel(self.logger.level)
        fh.setFormatter(formatter)
        self.logger.addHandler(fh)
    return logger


def get_parser():
    '''Get ArgumentParser'''
    parser = argparse.ArgumentParser(
                  description='''For the contaminant BAM file output generated 
                                 by BACTA on simulated reference and 
                                 contaminant reads generated by dwgsim, test  
                                 the sensitivity and specificity of contaminant 
                                 identification at different 'expect'
                                 thresholds.''',
                  add_help=False)
    required_args = parser.add_argument_group('Required Arguments')
    optional_args = parser.add_argument_group('Optional Arguments')
    required_args.add_argument('-i', '--bam', '--input', required=True, 
                               metavar='BAM', 
                               help='''Input BAM filename. This should be the
                                       output contaminant BAM file from BACTA 
                                       when run on mixed reference/contaminant 
                                       reads simulated using dwgsim.''')
    required_args.add_argument('-r', '--ref', required=True, metavar='FASTA', 
                               help='''Reference fasta file containing 
                                       original (i.e. non-contaminant)
                                       sequences. This file must have been 
                                       indexed by samtools.''')
    required_args.add_argument('-o', '--output', metavar='PREFIX', 
                               required=True,
                               help='''Prefix for plot and table output 
                                       files.''')
    optional_args.add_argument('-e', '--expect_values', type=float, nargs='+', 
                               metavar='E', default=[0, 1, 5, 10, 50, 100, 500,
                                                     1000, 2000, 5000, 10000,
                                                     20000, 50000, 100000],
                               help='''Expect values thesholds to test. 
                                       Default=[1, 5, 10, 50, 100, 500, 1000, 
                                       2000, 5000, 10000, 20000, 50000, 100000]
                                    ''')
    optional_args.add_argument('-d', '--decoy_contigs', nargs='+', 
                               metavar='CONTIG', 
                               default=['hs37d5', 'NC_007605'],
                               help='''Names of decoy contigs from input BAM. 
                                       Reads mapped to these contigs will be 
                                       ignored. Default=['hs37d5', 'NC_007605']
                                    ''')
    optional_args.add_argument('-a', '--avoid_regions', metavar='BED', 
                               help='''BED file of regions to ignore (e.g. 
                                       repetitive or low complexity regions).
                                    ''')
    optional_args.add_argument('-p', '--prog_interval', type=int, metavar='N',
                               default=1000000, 
                               help='''Report progress every N reads. 
                               Default=1000000''')
    optional_args.add_argument('-l', '--logfile', 
                               help='''Output logging information to this file
                                       (in addition to STDERR).''')
    optional_args.add_argument('--quiet', action='store_true',  
                               help='''Only output error and warning logging 
                                       information.''')
    optional_args.add_argument('--debug', action='store_true', 
                               help='''Output debugging information.''')
    optional_args.add_argument('-h', '--help', action='help', 
                               help='''show this help message and exit''')

    return parser

if __name__ == '__main__':
    parser = get_parser()
    args = parser.parse_args()
    test_expect(**vars(args))


